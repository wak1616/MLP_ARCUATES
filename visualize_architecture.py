from graphviz import Digraph

def visualize_network():
    dot = Digraph(comment='Monotonic Neural Network')
    dot.attr(rankdir='LR')
    
    # Add standard input features at top
    with dot.subgraph(name='cluster_0') as c:
        c.attr(color='lightgrey', label='''<<B>Standard Input Features</B>>''', penwidth='2.0')
        c.node('x1', 'Age')
        c.node('x2', 'Steep_axis_term')
        c.node('x3', 'MeanK_IOLMaster')
        c.node('x4', 'Treatment_astigmatism')
        c.node('x5', 'WTW_IOLMaster')
    
    # Add spacing nodes between clusters
    dot.node('gap1', style='invis')
    dot.node('gap2', style='invis')
    dot.node('gap3', style='invis')
    dot.edge('gap1', 'gap2', style='invis')
    dot.edge('gap2', 'gap3', style='invis')
    
    # Add monotonic input feature box with treated_astig inside, positioned lower and left-aligned
    with dot.subgraph(name='cluster_1') as c:
        c.attr(color='lightgrey', label='''<<B>Monotonic Input Feature</B>>''', penwidth='2.0')
        c.node('x6', 'treated_astig')
        c.attr(rank='sink')
        # Force left alignment
        c.graph_attr['labeljust'] = 'l'
        c.graph_attr['rankdir'] = 'LR'
        # Add invisible node to pull cluster left
        c.node('pull_left', style='invis', pos='0,0!')
        c.edge('pull_left', 'x6', style='invis')
    
    # Force gap nodes between clusters
    dot.edge('x5', 'gap1', style='invis')
    dot.edge('gap3', 'x6', style='invis')
    
    # Add constraint to align clusters
    dot.attr(constraint='false')  # Allow longer arrows
    
    # Add unconstrained path with updated description
    dot.node('hidden', '''<<B>Unconstrained Path</B><BR/><BR/>[Linear(input_dim → 48)]<BR/>↓<BR/>[LeakyReLU]<BR/>↓<BR/>[Linear(48 → 10)]<BR/>↓<BR/>[ReLU]<BR/><BR/>(generates coefficients)>''', 
             shape='box', style='filled', fillcolor='lightgreen', penwidth='2.0')
    
    # Add monotonic transformation nodes with extra spacing
    with dot.subgraph(name='cluster_2') as c:
        c.attr(color='lightblue', label='''<<B>Monotonic Layer</B><BR/><BR/>(Created from transformations of treated_astig.<BR/>Multiplied by coefficients generated by unconstrained path)>''')
        c.node('m1', 'constant')
        c.node('m2', 'linear')
        c.node('m3', 'logistic_shift_left_1')
        c.node('m4', 'logistic_shift_left_0.5')
        c.node('m5', 'logistic_center')
        c.node('m6', 'logarithmic')
        c.node('m7', 'logistic_shift_right_0.5')
        c.node('m8', 'logistic_shift_right_1')
        c.node('m9', 'logistic_shift_right_1.5')
        c.node('m10', 'logistic_shift_left_1.5')
    
    # Add output node with bold title, extra spacing, and updated description
    dot.node('out', '''<<B>Arcuate Sweep</B><BR/><BR/>(Sum of monotonic layer outputs / monotonic_feature_contributions)>''', 
             shape='doubleoctagon', penwidth='2.0')
    
    # Connect standard inputs to unconstrained path
    for i in range(5):
        dot.edge(f'x{i+1}', 'hidden', penwidth='1.5')
    
    # Connect treated_astig to monotonic transformations with blue arrows
    for i in range(10):
        dot.edge('x6', f'm{i+1}', penwidth='1.5', color='blue', label='transformation')
    
    # Connect unconstrained path to monotonic transformations with red arrows
    for i in range(10):
        dot.edge('hidden', f'm{i+1}', penwidth='1.5', color='red', label='coefficient')
    
    # Connect monotonic transformations to output
    for i in range(10):
        dot.edge(f'm{i+1}', 'out', penwidth='1.5')
    
    # Add processing notes with left-justified text
    dot.node('note1', '''<<B>Processing Notes:</B><BR ALIGN="LEFT"/>1. Input features feed into unconstrained path<BR ALIGN="LEFT"/>2. Unconstrained path generates coefficients for the Monotonic layer<BR ALIGN="LEFT"/>   by passing the input feature data through a simple neural network<BR ALIGN="LEFT"/>   (2 linear layers and 2 activation layers)<BR ALIGN="LEFT"/>3. Non-negative output maintained by ReLU<BR ALIGN="LEFT"/>4. treated_astig transformed to create monotonic layer units<BR ALIGN="LEFT"/>5. Transforms are multipied by the coefficients generated by unconstrained path<BR ALIGN="LEFT"/>6. Final output is sum of monotonic layer outputs>''', 
             shape='box', penwidth='2.0', margin='0.1,0.1')
    
    # Force note under standard input features
    dot.edge('x1', 'note1', style='invis', weight='100')  # Connect to leftmost standard input
    dot.node('anchor_left', style='invis', pos="-10,0!")  # Much further left position
    dot.edge('anchor_left', 'note1', style='invis', weight='200')  # Stronger pull left
    
    # Save the visualization
    dot.render('network_architecture', format='png', cleanup=True)

if __name__ == '__main__':
    visualize_network()

